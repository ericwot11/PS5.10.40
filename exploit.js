window.onload = function() {
    const exploitButton = document.getElementById("exploitButton");

    exploitButton.addEventListener("click", function() {
        // Lors du clic sur le bouton, on lance l'exploit
        startExploit();
    });
}

async function startExploit() {
    log("[D√âBUT] Lancement de l'exploit PS5...");
    try {
        // √âtape 1 : Escalade des privil√®ges via la cha√Æne ROP
        await escalatePrivileges();

        // √âtape 2 : Injection du shell ELF ou d'une commande
        await injectShell();

        // √âtape 3 : Extraction de la m√©moire avec d√©filement des adresses
        await dumpMemory();

        // √âtape 4 : Scan de la m√©moire pour des donn√©es sensibles
        await scanMemory();

        log("‚úÖ Exploit termin√© avec succ√®s !");
    } catch (e) {
        log(`‚ùå Erreur : ${e.message}`);
    }
}

// √âtape 1 : Escalade des privil√®ges via la cha√Æne ROP
async function escalatePrivileges() {
    log("üîê [√âtape 1] Escalade des privil√®ges via la cha√Æne ROP...");

    const ropChain = [
        window.rop.gadgets["pop rdi"],
        0xdeadbeef, // Adresse √† stocker
        window.rop.gadgets["pop rsi"],
        0xdeadbeef, // Autre valeur √† stocker
        window.rop.gadgets["mov [rdi], rsi"],  // Manipulation de la m√©moire
        window.rop.gadgets["ret"]  // Retour apr√®s l'ex√©cution
    ];

    for (let gadget of ropChain) {
        log(`üîó [ROP] Gadget ex√©cut√© : 0x${gadget.toString(16)}`);
        await delay(300); // Simule un d√©lai entre les gadgets
    }

    log("‚úÖ Privil√®ges kernel obtenus avec succ√®s.");
}

// √âtape 2 : Injection du shell ELF ou d'une commande
async function injectShell() {
    log("üíª [√âtape 2] Lancement du shell ELF interactif...");
    
    const shellCommand = "echo 'root access granted' > /tmp/hack.txt";
    log(`üíª [Shell] Commande ex√©cut√©e : ${shellCommand}`);

    await delay(500);
    log("üíª [Shell] Session termin√©e.");
}

// √âtape 3 : Extraction de la m√©moire avec d√©filement dynamique des adresses
async function dumpMemory() {
    log("üîç [√âtape 3] Extraction de la m√©moire avec d√©filement dynamique des adresses...");

    const startAddress = 0x100000;
    const endAddress = 0x800000;
    const step = 0x1000;  // Incr√©ment pour chaque adresse

    for (let addr = startAddress; addr < endAddress; addr += step) {
        log(`üìë [M√©moire] Dump √† l'adresse : 0x${addr.toString(16)}`);
        await delay(100);  // Simulation du d√©lai entre chaque adresse
    }

    log("‚úÖ Extraction de la m√©moire termin√©e.");
}

// √âtape 4 : Scan de la m√©moire pour d√©tecter des donn√©es sensibles
async function scanMemory() {
    log("üîç [√âtape 4] D√©but du scan de la m√©moire pour les fichiers sensibles...");

    let startAddress = 0x100000;
    let endAddress = 0x800000;

    for (let addr = startAddress; addr < endAddress; addr += 0x1000) {
        // Simule la lecture de la m√©moire du noyau
        let data = readKernelMemory(addr);
        if (isSensitiveData(data)) {
            log(`üîë Donn√©e sensible trouv√©e √† l'adresse : 0x${addr.toString(16)}`);
        }
    }

    log("‚úÖ Scan des fichiers termin√©.");
}

// Fonction de d√©lai pour simuler un temps d'attente entre les √©tapes
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// Fonction pour enregistrer et afficher les logs
function log(message) {
    const logDiv = document.getElementById("log");
    const logMessage = document.createElement("p");
    logMessage.textContent = message;
    logDiv.appendChild(logMessage);
}

// Simulation de la lecture de la m√©moire du noyau
function readKernelMemory(addr) {
    // Remplace ceci avec une vraie m√©thode de lecture de la m√©moire
    return "dummyData";
}

// Fonction pour v√©rifier si les donn√©es sont sensibles
function isSensitiveData(data) {
    // Ajoute une logique pour d√©tecter les donn√©es sensibles
    return data.includes("sensitive");
}
