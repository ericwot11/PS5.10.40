window.onload = function() {
    const exploitButton = document.getElementById("exploitButton");

    exploitButton.addEventListener("click", function() {
        // Lors du clic sur le bouton, on lance l'exploit.
        startExploit();
    });
}

async function startExploit() {
    log("[DÉBUT] Lancement de l'exploit PS5...");
    try {
        // Étape 1 : Escalade des privilèges via la chaîne ROP
        await escalatePrivileges();

        // Étape 2 : Injection du shell ELF ou commande
        await injectShell();

        // Étape 3 : Extraction de la mémoire avec défilement d'adresses
        await dumpMemory();

        log("✅ Exploit terminé avec succès !");
    } catch (e) {
        log(`❌ Erreur : ${e.message}`);
    }
}

// Étape 1 : Escalade des privilèges via ROP
async function escalatePrivileges() {
    log("🔐 [Étape 1] Escalade des privilèges via la chaîne ROP...");

    const ropChain = [
        window.rop.gadgets["pop rdi"],
        0xdeadbeef, // Adresse où l'on veut stocker la donnée
        window.rop.gadgets["pop rsi"],
        0xdeadbeef, // Valeur à stocker
        window.rop.gadgets["mov [rdi], rsi"], // Écriture dans la mémoire
        window.rop.gadgets["ret"] // Retour après l'exécution
    ];

    for (let gadget of ropChain) {
        log(`🔗 [ROP] Gadget exécuté : 0x${gadget.toString(16)}`);
        await delay(300); // Simulation d'un délai
    }

    log("✅ Privilèges kernel obtenus avec succès.");
}

// Étape 2 : Injection du shell ou commande
async function injectShell() {
    log("💻 [Étape 2] Lancement du shell interactif...");
    
    const shellCommand = "echo 'root access granted' > /tmp/hack.txt";
    log(`💻 [Shell] Commande exécutée : ${shellCommand}`);

    await delay(500);
    log("💻 [Shell] Session terminée.");
}

// Étape 3 : Extraction de la mémoire avec défilement d'adresses
async function dumpMemory() {
    log("🔍 [Étape 3] Extraction de la mémoire avec défilement dynamique des adresses...");

    const startAddress = 0x100000;
    const endAddress = 0x800000;
    const step = 0x1000;  // Incrément pour chaque adresse

    // Affichage des adresses à chaque itération, simulant un défilement de la mémoire
    for (let addr = startAddress; addr < endAddress; addr += step) {
        log(`📑 [Mémoire] Dump à l'adresse : 0x${addr.toString(16)}`);
        await delay(100);  // Simulation d'un délai entre les dumps d'adresses
    }

    log("✅ Extraction de la mémoire terminée.");
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function log(message) {
    const logDiv = document.getElementById("log");
    const logMessage = document.createElement("p");
    logMessage.textContent = message;
    logDiv.appendChild(logMessage);
}
