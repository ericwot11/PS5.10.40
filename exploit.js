window.onload = function() {
    const exploitButton = document.getElementById("exploitButton");

    exploitButton.addEventListener("click", function() {
        // Lors du clic sur le bouton, on lance l'exploit.
        startExploit();
    });
}

async function startExploit() {
    log("[DÃ‰BUT] Lancement de l'exploit PS5...");
    try {
        // Ã‰tape 1 : Escalade des privilÃ¨ges via la chaÃ®ne ROP
        await escalatePrivileges();

        // Ã‰tape 2 : Injection du shell ELF ou commande
        await injectShell();

        // Ã‰tape 3 : Extraction de la mÃ©moire avec dÃ©filement d'adresses
        await dumpMemory();

        log("âœ… Exploit terminÃ© avec succÃ¨s !");
    } catch (e) {
        log(`âŒ Erreur : ${e.message}`);
    }
}

// Ã‰tape 1 : Escalade des privilÃ¨ges via ROP
async function escalatePrivileges() {
    log("ğŸ” [Ã‰tape 1] Escalade des privilÃ¨ges via la chaÃ®ne ROP...");

    const ropChain = [
        window.rop.gadgets["pop rdi"],
        0xdeadbeef, // Adresse oÃ¹ l'on veut stocker la donnÃ©e
        window.rop.gadgets["pop rsi"],
        0xdeadbeef, // Valeur Ã  stocker
        window.rop.gadgets["mov [rdi], rsi"], // Ã‰criture dans la mÃ©moire
        window.rop.gadgets["ret"] // Retour aprÃ¨s l'exÃ©cution
    ];

    for (let gadget of ropChain) {
        log(`ğŸ”— [ROP] Gadget exÃ©cutÃ© : 0x${gadget.toString(16)}`);
        await delay(300); // Simulation d'un dÃ©lai
    }

    log("âœ… PrivilÃ¨ges kernel obtenus avec succÃ¨s.");
}

// Ã‰tape 2 : Injection du shell ou commande
async function injectShell() {
    log("ğŸ’» [Ã‰tape 2] Lancement du shell interactif...");
    
    const shellCommand = "echo 'root access granted' > /tmp/hack.txt";
    log(`ğŸ’» [Shell] Commande exÃ©cutÃ©e : ${shellCommand}`);

    await delay(500);
    log("ğŸ’» [Shell] Session terminÃ©e.");
}

// Ã‰tape 3 : Extraction de la mÃ©moire avec dÃ©filement d'adresses
async function dumpMemory() {
    log("ğŸ” [Ã‰tape 3] Extraction de la mÃ©moire avec dÃ©filement dynamique des adresses...");

    const startAddress = 0x100000;
    const endAddress = 0x800000;
    const step = 0x1000;  // IncrÃ©ment pour chaque adresse

    // Affichage des adresses Ã  chaque itÃ©ration, simulant un dÃ©filement de la mÃ©moire
    for (let addr = startAddress; addr < endAddress; addr += step) {
        log(`ğŸ“‘ [MÃ©moire] Dump Ã  l'adresse : 0x${addr.toString(16)}`);
        await delay(100);  // Simulation d'un dÃ©lai entre les dumps d'adresses
    }

    log("âœ… Extraction de la mÃ©moire terminÃ©e.");
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function log(message) {
    const logDiv = document.getElementById("log");
    const logMessage = document.createElement("p");
    logMessage.textContent = message;
    logDiv.appendChild(logMessage);
}
